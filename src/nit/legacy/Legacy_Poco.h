//
// This source file is from part of poco library
//
// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#pragma once

#include "nit/nit.h"

#include "nit/async/AtomicInt.h"

////////////////////////////////////////////////////////////////////////////////

#include <ctime>
#include <vector>
#include <setjmp.h>

NS_NIT_BEGIN;

////////////////////////////////////////////////////////////////////////////////

// Timestamp

class NIT_API PocoTimestamp
	/// A Timestamp stores a monotonic* time value
	/// with (theoretical) microseconds resolution.
	/// Timestamps can be compared with each other
	/// and simple arithmetics are supported.
	///
	/// [*] Note that Timestamp values are only monotonic as
	/// long as the systems's clock is monotonic as well
	/// (and not, e.g. set back).
	///
	/// Timestamps are UTC (Coordinated Universal Time)
	/// based and thus independent of the timezone
	/// in effect on the system.
{
public:
	typedef int64 Int64;
	typedef uint32 UInt32;

	typedef Int64 TimeVal;    /// monotonic UTC time value in microsecond resolution
	typedef Int64 UtcTimeVal; /// monotonic UTC time value in 100 nanosecond resolution
	typedef Int64 TimeDiff;   /// difference between two timestamps in microseconds

	PocoTimestamp();
	/// Creates a timestamp with the current time.

	PocoTimestamp(TimeVal tv);
	/// Creates a timestamp from the given time value.

	PocoTimestamp(const PocoTimestamp& other);
	/// Copy constructor.

	~PocoTimestamp();
	/// Destroys the timestamp

	PocoTimestamp& operator = (const PocoTimestamp& other);
	PocoTimestamp& operator = (TimeVal tv);

	void swap(PocoTimestamp& timestamp);
	/// Swaps the Timestamp with another one.

	void update();
	/// Updates the Timestamp with the current time.

	bool operator == (const PocoTimestamp& ts) const;
	bool operator != (const PocoTimestamp& ts) const;
	bool operator >  (const PocoTimestamp& ts) const;
	bool operator >= (const PocoTimestamp& ts) const;
	bool operator <  (const PocoTimestamp& ts) const;
	bool operator <= (const PocoTimestamp& ts) const;

	PocoTimestamp  operator +  (TimeDiff d) const;
	PocoTimestamp  operator -  (TimeDiff d) const;
	TimeDiff   operator -  (const PocoTimestamp& ts) const;
	PocoTimestamp& operator += (TimeDiff d);
	PocoTimestamp& operator -= (TimeDiff d);

	std::time_t epochTime() const;
	/// Returns the timestamp expressed in time_t.
	/// time_t base time is midnight, January 1, 1970.
	/// Resolution is one second.

	UtcTimeVal utcTime() const;
	/// Returns the timestamp expressed in UTC-based
	/// time. UTC base time is midnight, October 15, 1582.
	/// Resolution is 100 nanoseconds.

	TimeVal epochMicroseconds() const;
	/// Returns the timestamp expressed in microseconds
	/// since the Unix epoch, midnight, January 1, 1970.

	TimeDiff elapsed() const;
	/// Returns the time elapsed since the time denoted by
	/// the timestamp. Equivalent to Timestamp() - *this.

	bool isElapsed(TimeDiff interval) const;
	/// Returns true iff the given interval has passed
	/// since the time denoted by the timestamp.

	static PocoTimestamp fromEpochTime(std::time_t t);
	/// Creates a timestamp from a std::time_t.

	static PocoTimestamp fromUtcTime(UtcTimeVal val);
	/// Creates a timestamp from a UTC time value.

	static TimeVal resolution();
	/// Returns the resolution in units per second.
	/// Since the timestamp has microsecond resolution,
	/// the returned value is always 1000000.

#if defined(_WIN32)
	static PocoTimestamp fromFileTimeNP(UInt32 fileTimeLow, UInt32 fileTimeHigh);
	void toFileTimeNP(UInt32& fileTimeLow, UInt32& fileTimeHigh) const;
#endif

private:
	TimeVal _ts;
};


//
// inlines
//
inline bool PocoTimestamp::operator == (const PocoTimestamp& ts) const
{
	return _ts == ts._ts;
}


inline bool PocoTimestamp::operator != (const PocoTimestamp& ts) const
{
	return _ts != ts._ts;
}


inline bool PocoTimestamp::operator >  (const PocoTimestamp& ts) const
{
	return _ts > ts._ts;
}


inline bool PocoTimestamp::operator >= (const PocoTimestamp& ts) const
{
	return _ts >= ts._ts;
}


inline bool PocoTimestamp::operator <  (const PocoTimestamp& ts) const
{
	return _ts < ts._ts;
}


inline bool PocoTimestamp::operator <= (const PocoTimestamp& ts) const
{
	return _ts <= ts._ts;
}


inline PocoTimestamp PocoTimestamp::operator + (PocoTimestamp::TimeDiff d) const
{
	return PocoTimestamp(_ts + d);
}


inline PocoTimestamp PocoTimestamp::operator - (PocoTimestamp::TimeDiff d) const
{
	return PocoTimestamp(_ts - d);
}


inline PocoTimestamp::TimeDiff PocoTimestamp::operator - (const PocoTimestamp& ts) const
{
	return _ts - ts._ts;
}


inline PocoTimestamp& PocoTimestamp::operator += (PocoTimestamp::TimeDiff d)
{
	_ts += d;
	return *this;
}


inline PocoTimestamp& PocoTimestamp::operator -= (PocoTimestamp::TimeDiff d)
{
	_ts -= d;
	return *this;
}


inline std::time_t PocoTimestamp::epochTime() const
{
	return std::time_t(_ts/resolution());
}


inline PocoTimestamp::UtcTimeVal PocoTimestamp::utcTime() const
{
	return _ts*10 + (TimeDiff(0x01b21dd2) << 32) + 0x13814000;
}


inline PocoTimestamp::TimeVal PocoTimestamp::epochMicroseconds() const
{
	return _ts;
}


inline PocoTimestamp::TimeDiff PocoTimestamp::elapsed() const
{
	PocoTimestamp now;
	return now - *this;
}


inline bool PocoTimestamp::isElapsed(PocoTimestamp::TimeDiff interval) const
{
	PocoTimestamp now;
	PocoTimestamp::TimeDiff diff = now - *this;
	return diff >= interval;
}


inline PocoTimestamp::TimeVal PocoTimestamp::resolution()
{
	return 1000000;
}


inline void swap(PocoTimestamp& s1, PocoTimestamp& s2)
{
	s1.swap(s2);
}

////////////////////////////////////////////////////////////////////////////////

class NIT_API Timespan
	/// A class that represents time spans up to microsecond resolution.
{
public:
	typedef PocoTimestamp::TimeDiff TimeDiff;

	Timespan();
	/// Creates a zero Timespan.

	Timespan(TimeDiff microseconds);
	/// Creates a Timespan.

	Timespan(long seconds, long microseconds);
	/// Creates a Timespan. Useful for creating
	/// a Timespan from a struct timeval.

	Timespan(int days, int hours, int minutes, int seconds, int microseconds);
	/// Creates a Timespan.

	Timespan(const Timespan& timespan);
	/// Creates a Timespan from another one.

	~Timespan();
	/// Destroys the Timespan.

	Timespan& operator = (const Timespan& timespan);
	/// Assignment operator.

	Timespan& operator = (TimeDiff microseconds);
	/// Assignment operator.

	Timespan& assign(int days, int hours, int minutes, int seconds, int microseconds);
	/// Assigns a new span.

	Timespan& assign(long seconds, long microseconds);
	/// Assigns a new span. Useful for assigning
	/// from a struct timeval.

	void swap(Timespan& timespan);
	/// Swaps the Timespan with another one.

	bool operator == (const Timespan& ts) const;
	bool operator != (const Timespan& ts) const;
	bool operator >  (const Timespan& ts) const;
	bool operator >= (const Timespan& ts) const;
	bool operator <  (const Timespan& ts) const;
	bool operator <= (const Timespan& ts) const;

	bool operator == (TimeDiff microseconds) const;
	bool operator != (TimeDiff microseconds) const;
	bool operator >  (TimeDiff microseconds) const;
	bool operator >= (TimeDiff microseconds) const;
	bool operator <  (TimeDiff microseconds) const;
	bool operator <= (TimeDiff microseconds) const;

	Timespan operator + (const Timespan& d) const;
	Timespan operator - (const Timespan& d) const;
	Timespan& operator += (const Timespan& d);
	Timespan& operator -= (const Timespan& d);

	Timespan operator + (TimeDiff microseconds) const;
	Timespan operator - (TimeDiff microseconds) const;
	Timespan& operator += (TimeDiff microseconds);
	Timespan& operator -= (TimeDiff microseconds);

	int days() const;
	/// Returns the number of days.

	int hours() const;
	/// Returns the number of hours (0 to 23).

	int totalHours() const;
	/// Returns the total number of hours.

	int minutes() const;
	/// Returns the number of minutes (0 to 59).

	int totalMinutes() const;
	/// Returns the total number of minutes.

	int seconds() const;
	/// Returns the number of seconds (0 to 59).

	int totalSeconds() const;
	/// Returns the total number of seconds.

	int milliseconds() const;
	/// Returns the number of milliseconds (0 to 999).

	TimeDiff totalMilliseconds() const;
	/// Returns the total number of milliseconds.

	int microseconds() const;
	/// Returns the fractions of a millisecond
	/// in microseconds (0 to 999).

	int useconds() const;
	/// Returns the fractions of a second
	/// in microseconds (0 to 999999).

	TimeDiff totalMicroseconds() const;
	/// Returns the total number of microseconds.

	static const TimeDiff MILLISECONDS; /// The number of microseconds in a millisecond.
	static const TimeDiff SECONDS;      /// The number of microseconds in a second.
	static const TimeDiff MINUTES;      /// The number of microseconds in a minute.
	static const TimeDiff HOURS;        /// The number of microseconds in a hour.
	static const TimeDiff DAYS;         /// The number of microseconds in a day.

private:
	TimeDiff _span;
};


//
// inlines
//
inline int Timespan::days() const
{
	return int(_span/DAYS);
}


inline int Timespan::hours() const
{
	return int((_span/HOURS) % 24);
}


inline int Timespan::totalHours() const
{
	return int(_span/HOURS);
}


inline int Timespan::minutes() const
{
	return int((_span/MINUTES) % 60);
}


inline int Timespan::totalMinutes() const
{
	return int(_span/MINUTES);
}


inline int Timespan::seconds() const
{
	return int((_span/SECONDS) % 60);
}


inline int Timespan::totalSeconds() const
{
	return int(_span/SECONDS);
}


inline int Timespan::milliseconds() const
{
	return int((_span/MILLISECONDS) % 1000);
}


inline Timespan::TimeDiff Timespan::totalMilliseconds() const
{
	return _span/MILLISECONDS;
}


inline int Timespan::microseconds() const
{
	return int(_span % 1000);
}


inline int Timespan::useconds() const
{
	return int(_span % 1000000);
}


inline Timespan::TimeDiff Timespan::totalMicroseconds() const
{
	return _span;
}


inline bool Timespan::operator == (const Timespan& ts) const
{
	return _span == ts._span;
}


inline bool Timespan::operator != (const Timespan& ts) const
{
	return _span != ts._span;
}


inline bool Timespan::operator >  (const Timespan& ts) const
{
	return _span > ts._span;
}


inline bool Timespan::operator >= (const Timespan& ts) const
{
	return _span >= ts._span;
}


inline bool Timespan::operator <  (const Timespan& ts) const
{
	return _span < ts._span;
}


inline bool Timespan::operator <= (const Timespan& ts) const
{
	return _span <= ts._span;
}


inline bool Timespan::operator == (TimeDiff microseconds) const
{
	return _span == microseconds;
}


inline bool Timespan::operator != (TimeDiff microseconds) const
{
	return _span != microseconds;
}


inline bool Timespan::operator >  (TimeDiff microseconds) const
{
	return _span > microseconds;
}


inline bool Timespan::operator >= (TimeDiff microseconds) const
{
	return _span >= microseconds;
}


inline bool Timespan::operator <  (TimeDiff microseconds) const
{
	return _span < microseconds;
}


inline bool Timespan::operator <= (TimeDiff microseconds) const
{
	return _span <= microseconds;
}


inline void swap(Timespan& s1, Timespan& s2)
{
	s1.swap(s2);
}

////////////////////////////////////////////////////////////////////////////////

// Runnable

class NIT_API Runnable
	/// The Runnable interface with the run() method
	/// must be implemented by classes that provide
	/// an entry point for a thread.
{
public:	
	Runnable();
	virtual ~Runnable();

	virtual void run() = 0;
	/// Do whatever the thread needs to do. Must
	/// be overridden by subclasses.
};

////////////////////////////////////////////////////////////////////////////////

// RefCountedObject

class NIT_API RefCountedObject
	/// A base class for objects that employ
	/// reference counting based garbage collection.
	///
	/// Reference-counted objects inhibit construction
	/// by copying and assignment.
{
public:
	RefCountedObject() : _counter(1) { }
	/// Creates the RefCountedObject.
	/// The initial reference count is one.

	void duplicate() const				{ _counter.inc(); }
	/// Increments the object's reference count.

	void release() const				{ if (_counter.decGet() == 0) delete this; }
	/// Decrements the object's reference count
	/// and deletes the object if the count
	/// reaches zero.

	int referenceCount() const			{ return _counter._unsafeGet(); }
	/// Returns the reference count.

protected:
	virtual ~RefCountedObject()		{ }
	/// Destroys the RefCountedObject.

private:
	RefCountedObject(const RefCountedObject&);
	RefCountedObject& operator = (const RefCountedObject&);

	mutable AtomicInt _counter;
};

////////////////////////////////////////////////////////////////////////////////

template <class C>
class AutoPtr
	/// AutoPtr is a "smart" pointer for classes implementing
	/// reference counting based garbage collection.
	/// To be usable with the AutoPtr template, a class must
	/// implement the following behaviour:
	/// A class must maintain a reference count.
	/// The constructors of the object initialize the reference
	/// count to one.
	/// The class must implement a public duplicate() method:
	///     void duplicate();
	/// that increments the reference count by one.
	/// The class must implement a public release() method:
	///     void release()
	/// that decrements the reference count by one, and,
	/// if the reference count reaches zero, deletes the
	/// object.
	///
	/// AutoPtr works in the following way:
	/// If an AutoPtr is assigned an ordinary pointer to
	/// an object (via the constructor or the assignment operator),
	/// it takes ownership of the object and the object's reference 
	/// count remains unchanged.
	/// If the AutoPtr is assigned another AutoPtr, the
	/// object's reference count is incremented by one by
	/// calling duplicate() on its object.
	/// The destructor of AutoPtr calls release() on its
	/// object.
	/// AutoPtr supports dereferencing with both the ->
	/// and the * operator. An attempt to dereference a null
	/// AutoPtr results in a NullPointerException being thrown.
	/// AutoPtr also implements all relational operators.
	/// Note that AutoPtr allows casting of its encapsulated data types.
{
public:
	AutoPtr(): _ptr(0)
	{
	}

	AutoPtr(C* ptr): _ptr(ptr)
	{
	}

	AutoPtr(C* ptr, bool shared): _ptr(ptr)
	{
		if (shared && _ptr) _ptr->duplicate();
	}

	AutoPtr(const AutoPtr& ptr): _ptr(ptr._ptr)
	{
		if (_ptr) _ptr->duplicate();
	}

	template <class Other> 
	AutoPtr(const AutoPtr<Other>& ptr): _ptr(const_cast<Other*>(ptr.get()))
	{
		if (_ptr) _ptr->duplicate();
	}

	~AutoPtr()
	{
		if (_ptr) _ptr->release();
	}

	AutoPtr& assign(C* ptr)
	{
		if (_ptr != ptr)
		{
			if (_ptr) _ptr->release();
			_ptr = ptr;
		}
		return *this;
	}

	AutoPtr& assign(C* ptr, bool shared)
	{
		if (_ptr != ptr)
		{
			if (_ptr) _ptr->release();
			_ptr = ptr;
			if (shared && _ptr) _ptr->duplicate();
		}
		return *this;
	}

	AutoPtr& assign(const AutoPtr& ptr)
	{
		if (&ptr != this)
		{
			if (_ptr) _ptr->release();
			_ptr = ptr._ptr;
			if (_ptr) _ptr->duplicate();
		}
		return *this;
	}

	template <class Other> 
	AutoPtr& assign(const AutoPtr<Other>& ptr)
	{
		if (ptr.get() != _ptr)
		{
			if (_ptr) _ptr->release();
			_ptr = const_cast<Other*>(ptr.get());
			if (_ptr) _ptr->duplicate();
		}
		return *this;
	}

	AutoPtr& operator = (C* ptr)
	{
		return assign(ptr);
	}

	AutoPtr& operator = (const AutoPtr& ptr)
	{
		return assign(ptr);
	}

	template <class Other> 
	AutoPtr& operator = (const AutoPtr<Other>& ptr)
	{
		return assign<Other>(ptr);
	}

	void swap(AutoPtr& ptr)
	{
		std::swap(_ptr, ptr._ptr);
	}

	template <class Other> 
	AutoPtr<Other> cast() const
		/// Casts the AutoPtr via a dynamic cast to the given type.
		/// Returns an AutoPtr containing NULL if the cast fails.
		/// Example: (assume class Sub: public Super)
		///    AutoPtr<Super> super(new Sub());
		///    AutoPtr<Sub> sub = super.cast<Sub>();
		///    poco_assert (sub.get());
	{
		Other* pOther = dynamic_cast<Other*>(_ptr);
		return AutoPtr<Other>(pOther, true);
	}

	template <class Other> 
	AutoPtr<Other> unsafeCast() const
		/// Casts the AutoPtr via a static cast to the given type.
		/// Example: (assume class Sub: public Super)
		///    AutoPtr<Super> super(new Sub());
		///    AutoPtr<Sub> sub = super.unsafeCast<Sub>();
		///    poco_assert (sub.get());
	{
		Other* pOther = static_cast<Other*>(_ptr);
		return AutoPtr<Other>(pOther, true);
	}

	C* operator -> ()
	{
		if (_ptr)
			return _ptr;
		else
			NIT_THROW(EX_NULL);
	}

	const C* operator -> () const
	{
		if (_ptr)
			return _ptr;
		else
			NIT_THROW(EX_NULL);
	}

	C& operator * ()
	{
		if (_ptr)
			return *_ptr;
		else
			NIT_THROW(EX_NULL);
	}

	const C& operator * () const
	{
		if (_ptr)
			return *_ptr;
		else
			NIT_THROW(EX_NULL);
	}

	C* get()
	{
		return _ptr;
	}

	const C* get() const
	{
		return _ptr;
	}

	operator C* ()
	{
		return _ptr;
	}

	operator const C* () const
	{
		return _ptr;
	}

	bool operator ! () const
	{
		return _ptr == 0;
	}

	bool isNull() const
	{
		return _ptr == 0;
	}

	C* duplicate()
	{
		if (_ptr) _ptr->duplicate();
		return _ptr;
	}

	bool operator == (const AutoPtr& ptr) const
	{
		return _ptr == ptr._ptr;
	}

	bool operator == (const C* ptr) const
	{
		return _ptr == ptr;
	}

	bool operator == (C* ptr) const
	{
		return _ptr == ptr;
	}

	bool operator != (const AutoPtr& ptr) const
	{
		return _ptr != ptr._ptr;
	}

	bool operator != (const C* ptr) const
	{
		return _ptr != ptr;
	}

	bool operator != (C* ptr) const
	{
		return _ptr != ptr;
	}

	bool operator < (const AutoPtr& ptr) const
	{
		return _ptr < ptr._ptr;
	}

	bool operator < (const C* ptr) const
	{
		return _ptr < ptr;
	}

	bool operator < (C* ptr) const
	{
		return _ptr < ptr;
	}

	bool operator <= (const AutoPtr& ptr) const
	{
		return _ptr <= ptr._ptr;
	}

	bool operator <= (const C* ptr) const
	{
		return _ptr <= ptr;
	}

	bool operator <= (C* ptr) const
	{
		return _ptr <= ptr;
	}

	bool operator > (const AutoPtr& ptr) const
	{
		return _ptr > ptr._ptr;
	}

	bool operator > (const C* ptr) const
	{
		return _ptr > ptr;
	}

	bool operator > (C* ptr) const
	{
		return _ptr > ptr;
	}

	bool operator >= (const AutoPtr& ptr) const
	{
		return _ptr >= ptr._ptr;
	}

	bool operator >= (const C* ptr) const
	{
		return _ptr >= ptr;
	}

	bool operator >= (C* ptr) const
	{
		return _ptr >= ptr;
	}

private:
	C* _ptr;
};


template <class C>
inline void swap(AutoPtr<C>& p1, AutoPtr<C>& p2)
{
	p1.swap(p2);
}

////////////////////////////////////////////////////////////////////////////////

#if defined(NIT_FAMILY_UNIX)

class NIT_API SignalHandler
	/// This helper class simplifies the handling of POSIX signals.
	///
	/// The class provides a signal handler (installed with
	/// installHandlers()) that translates certain POSIX
	/// signals (SIGILL, SIGBUS, SIGSEGV, SIGSYS) into 
	/// C++ exceptions.
	///
	/// Internally, a stack of sigjmp_buf structs is maintained for
	/// each thread. The constructor pushes a new sigjmp_buf onto
	/// the current thread's stack. The destructor pops the sigjmp_buf
	/// from the stack.
	///
	/// The poco_throw_on_signal macro creates an instance of SignalHandler
	/// on the stack, which results in a new sigjmp_buf being created.
	/// The sigjmp_buf is then set-up with sigsetjmp().
	///
	/// The handleSignal() method, which is invoked when a signal arrives,
	/// checks if a sigjmp_buf is available for the current thread.
	/// If so, siglongjmp() is used to jump out of the signal handler.
	///
	/// Typical usage is as follows:
	///
	///     try
	///     {
	///          poco_throw_on_signal;
	///          ...
	///     }
	///     catch (Poco::SignalException&)
	///     {
	///         ...
	///     }
	///
	/// The best way to deal with a SignalException is to log as much context
	/// information as possible, to aid in debugging, and then to exit.
	///
	/// The SignalHandler can be disabled globally by compiling POCO and client
	/// code with the POCO_NO_SIGNAL_HANDLER macro defined.
{
public:
	SignalHandler();
	/// Creates the SignalHandler.

	~SignalHandler();
	/// Destroys the SignalHandler.

	sigjmp_buf& jumpBuffer();
	/// Returns the top-most sigjmp_buf for the current thread.

	static void throwSignalException(int sig);
	/// Throws a SignalException with a textual description  
	/// of the given signal as argument. 

	static void install();
	/// Installs signal handlers for SIGILL, SIGBUS, SIGSEGV
	/// and SIGSYS.

protected:
	static void handleSignal(int sig);
	/// The actual signal handler.

	struct JumpBuffer
		/// sigjmp_buf cannot be used to instantiate a std::vector,
		/// so we provide a wrapper struct.
	{
		sigjmp_buf buf;
	};
	typedef std::vector<JumpBuffer> JumpBufferVec;

	static JumpBufferVec& jumpBufferVec();
	/// Returns the JumpBufferVec for the current thread.

private:
	static JumpBufferVec _jumpBufferVec;

	friend class ThreadImpl;
};


#ifndef POCO_NO_SIGNAL_HANDLER
#define poco_throw_on_signal \
	Poco::SignalHandler _poco_signalHandler; \
	int _poco_signal = sigsetjmp(_poco_signalHandler.jumpBuffer(), 1); \
	if (_poco_signal) _poco_signalHandler.throwSignalException(_poco_signal);
#else
#define poco_throw_on_signal
#endif

#endif

////////////////////////////////////////////////////////////////////////////////

// SingletonHolder

template <typename S, typename TMutex>
class SingletonHolder
	/// This is a helper template class for managing
	/// singleton objects allocated on the heap.
	/// The class ensures proper deletion (including
	/// calling of the destructor) of singleton objects
	/// when the application that created them terminates.
{
public:
	SingletonHolder()
		/// Creates the SingletonHolder.
	{
		_pS = 0;
	}
	~SingletonHolder()
		/// Destroys the SingletonHolder and the singleton
		/// object that it holds.
	{
		delete _pS;
	}
	S* get()
		/// Returns a pointer to the singleton object
		/// hold by the SingletonHolder. The first call
		/// to get will create the singleton.
	{
		typename TMutex::ScopedLock lock(_m);
		if (!_pS) _pS = new S;
		return _pS;
	}

private:
	S* _pS;
	TMutex _m;
};

////////////////////////////////////////////////////////////////////////////////

NS_NIT_END;
